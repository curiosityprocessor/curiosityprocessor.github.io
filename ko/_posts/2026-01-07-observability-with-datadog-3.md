---
title: "Datadog을 통한 Observability 확보 여정 #3"
date: 2025-12-30
lang: ko
categories:
  - DevOps
tags:
  - DevOps
  - Solutions
excerpt: "#3 최적화와 향후 계획"
---

# 앞으로의 여정
지금까지는 observability를 **확보**하기 위한 노력이었다면,  
이제부터는 최적화를 통해 **의사결정의 기준**이 되는 단계에 들어섰다.  

## 알림 최적화
가장 큰 우선순위는 알림을 최적화하는 단계일 것이다.  
현재까지는 "누구에게" 알림을 보낼 것인가보다  
"얼마나 빠르게" 보낼 것인지에 초점을 맞추었다.  

그러다보니 업무적으로 관련 적은 알림에도 반응해야하고  
지표 알림과 장애 알림을 구별없이 받아야했다.  

이는 결국 알림에 대한 피로도로 이어져 정작 중요한 알림을 중요한 순간에 놓칠 가능성을 높인다.  

따라서 다음과 같은 작업이 필요하다.
- 장애 등급 체계 (P1~P5)
- DRI/온콜 담당자 지정

장애 등급 같은 경우 팀원과 충분히 협의가 된 기준이 필요하고  
단순히 등급 지정 뿐만 아니라 **등급 별 대응 방안**도 명시적으로 있어야 한다.  
(ex P1의 경우 모든 진행중인 업무 중단하고 대응, 1시간 이내 이슈 해소 목표로 등)  
또한 등급별로 알림의 형태나 발송 주기, 발송시간도 조정할 필요가 있다.  
예를 들어 P1의 경우 즉각 발송, 1시간 후에도 미조치 시 재발송 하고  
P5의 경우 평일 아침 9시에 취합해서 보고서 형태로 제공하는 방식도 생각해볼 수 있다.  
중요도에 따라 알림 채널도 구분하는 것도 고려해볼만 하다.  

DRI/온콜 같은 경우 현재 팀 특성 상 특정 서비스나 도메인 단위로 담당자를 고정할 수는 없다.  
그렇다면 프론트/백과 같은 역할 단위로 구분하거나, 로테이션하는 방식으로라도 담당자를 지정해서  
가장 먼저 인지하고 **전체적인 장애 대응을 조율**할 사람과  
구체적인 **원인 파악**을 진행하고 **수정사항**을 배포할 사람의 역할을 분배해야 할 것이다.  

장애 등급 체계를 정의하고 담당자를 지정할 수 있게 되면  
observability는 장애 대응 능력을 갖추는데 멈추지 않고  
어떤 장애가 어떤 시스템에 어떤 빈도로 발생하는지,  
그리고 누가 어떻게 해결하였는지를 바탕으로  
구체적인 장애 대응 프로세스를 수립하는 의사결정에 도움을 줄 것이다.  

## 비용 최적화
그 다음으로는 현실적인 측면에서 비용 최적화를 고려하지 않을 수 없다.  
데이터독은 강력한 기능을 제공하지만 그만큼 비용도 비례하기 때문에  
활용하지 않는 기능은 과감히 비활성화하고, 불필요한 비용이 발생하지 않는지 계속 점검해야 한다.  
결국 비용 역시 observability의 대상이 되어야 할 것이다.  

장애 예방/탐지/대응 활동을 해가며 어떤 기능을 주로 사용하는지 트레킹 해보고  
사용하는 기능에 대한 정당성을 확보하고 새로 필요한 기능이 있는지 검토하게 되면  
비용에 대한 observability도 단지 비용 절감에 그치지 않고  
어떤 기능이 어디까지 필요한지에 대한 의사결정의 기준이 될 것이다.  

대표적인 예시로 프론트엔드 모니터링인 RUM의 비용이 꽤 높은 편인데 세션 당 과금 방식에 심지어 비용 상한을 줄 수 없어,  
전체 도입 시 과도한 비용이 발생해 실무적으로 어느 기능까지 꼭 필요한가를 다시 점검하게 되었고,  
세션 샘플링을 통해 일부 세션만 추적한다던가 retention filter를 통해 에러가 발생한 세션만 보존한다던가 하는 방향으로 최적화를 했다.  

## 개발 라이프싸이클 통합
마지막으로는 observability를 개발 라이프싸이클에 통합하는 방식을 기대하고 있다.  

설계 단계부터 observability를 고려하여 서비스 구분과 트레이스 연계를 고민하고  

개발 단계에서는 개발자에게 **실행가능한 빠른 피드백**을 주는 것을 목표로  
예를 들어 서비스에 대한 지표 분석으로부터 기능 개선 요청이 발생하고  
기능 추가/변경 시 관련 서비스에 대한 영향도를 파악할 수 있고  
호출량이나 패턴등을 통해 분산처리나 대용량 트래픽 대응, 또는 성능 검증이 필요한지와 같은  
다양한 기능적/비기능적 인싸이트를 얻을 수 있게 될 것이다.  

배포 단계에서는 정적/동적 코드 취약점을 병행하여 취약한 코드가 배포되지 못하게 차단하거나  
배포 환경별 또는 배포 단계별 API 응답시간과 같은 퍼포먼스 모니터링을 통과해야 다음 배포가 가능하게 설정할 수 있다.  
성공적인 배포 이후에는 배포 정보를 추적해 배포 버전별로 퍼포먼스를 비교하고 리포트를 생성할 수도 있을 것이다.  

장애 대응 이후에는 관련 트레이스와 메트릭, 그리고 장애 대응으로 수정한 내역을 같이 추적하여  
post-mortem 문서화와 팀내 공유 그리고 관련 지식 축적까지 기대해볼 수 있을 것이다.  

이렇게 observability는 문제가 터지면 찾아 꺼내는 "**청소도구함**"을 넘어  
무엇을 먼저 정리해야 할지 알려주는 "**나침반**"이 되어가고 있다.
